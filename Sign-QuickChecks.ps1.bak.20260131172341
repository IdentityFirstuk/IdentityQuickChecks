<#
.SYNOPSIS
    Sign all IdentityFirst QuickChecks PowerShell scripts.

.DESCRIPTION
    Digitally signs all .ps1 and .psm1 files in the QuickChecks module.
    Requires a valid Code Signing certificate.

.OUTPUTS
    - Signed script files
    - Console output showing sign status

.NOTES
    Author: IdentityFirst Ltd
    Requirements:
        - PowerShell 5.1+
        - Code Signing certificate (from trusted CA)
        - Local certificate store access or PFX file

.USAGE
    # Sign with certificate from local store
    .\Sign-QuickChecks.ps1
    
    # Sign with PFX file (recommended: pass SecureString or set IFQC_DEV_PFX_PASSWORD)
    .\Sign-QuickChecks.ps1 -CertPath ".\cert.pfx" -CertPassword (Read-Host "PFX password" -AsSecureString)
    
    # Dry run (show what would be signed)
    .\Sign-QuickChecks.ps1 -DryRun
#>

[CmdletBinding()]
param(
    [Parameter()]
    [string]$ModulePath = (Split-Path -Parent (Split-Path -Parent $PSScriptRoot)),
    
    [Parameter()]
    [string]$CertPath,
    
    [Parameter()]
    [securestring]$CertPassword,
    
    [Parameter()]
    [switch]$DryRun,
    
    [Parameter()]
    [switch]$Help
    ,
    [Parameter()]
    [pscredential]$CertCredential
)

if ($Help) {
    Write-Output @"
IdentityFirst QuickChecks - Script Signing Tool
================================================

This script digitally signs all PowerShell scripts in the QuickChecks module.

PREREQUISITES:
- PowerShell 5.1+
- Code Signing certificate from a trusted Certificate Authority
- Certificate must be in Local Machine or Current User store, or provided as PFX

USAGE:
  .\Sign-QuickChecks.ps1                    # Sign with cert from store
  .\Sign-QuickChecks.ps1 -CertPath ".\cert.pfx" -CertPassword (ConvertTo-SecureString "password" -AsPlainText -Force)
  .\Sign-QuickChecks.ps1 -DryRun            # Show what would be signed

WHAT GETS SIGNED:
- *.ps1 files (scripts)
- *.psm1 files (modules)
- *.psd1 files (module manifests)

WHY SIGN?
- Verifies script integrity
- Prevents tampering
- Establishes trust
- Required for some security policies

CERTIFICATE REQUIREMENTS:
- Template: Code Signing
- Extended Key Usage: Code Signing (1.3.6.1.5.5.7.3.3)
- Must be from trusted CA (e.g., DigiCert, Sectigo, GoDaddy)

AFTER SIGNING:
1. Test scripts still work
2. Distribute to users
3. Users may need to trust your publisher certificate

"@
    exit 0
}

$script:signCount = 0
$script:failCount = 0
$script:skipCount = 0

function Write-SignedLog {
    param([string]$Message, [string]$Level = "INFO")
    $ts = Get-Date -Format "HH:mm:ss"
    $color = if ($Level -eq "ERROR") { "Red" } elseif ($Level -eq "WARN" -or $Level -eq 'WARNING') { "Yellow" } else { "Gray" }
    $line = "[$ts] [$Level] $Message"

    # Emit structured log object to pipeline for capture
    $obj = [PSCustomObject]@{
        Timestamp = (Get-Date).ToString('o')
        ShortTimestamp = $ts
        Level = $Level
        Message = $Message
        Text = $line
        Type = 'Signing'
    }
    Write-IFQC -InputObject $obj

    # Also write human-friendly colored output to console
    try {
        $oldColor = $null
        try { $oldColor = $host.UI.RawUI.ForegroundColor } catch { }
        try { $host.UI.RawUI.ForegroundColor = [System.ConsoleColor]::$color } catch { }
        Write-Output $line
        if ($oldColor -ne $null) { try { $host.UI.RawUI.ForegroundColor = $oldColor } catch { } }
    } catch {
        Write-Output $line
    }
}

function Get-Certificate {
    <#
    .SYNOPSIS
        Gets the code signing certificate.
    #>
    
    # Try PFX file first
    if ($CertPath) {
        Write-SignedLog -Message "Loading certificate from PFX: $CertPath" -Level INFO

        if (-not $CertPassword) {
            # If caller provided a PSCredential, prefer its `Password` (SecureString)
            if ($CertCredential -and -not $CertPassword) {
                $CertPassword = $CertCredential.Password
                Write-SignedLog -Message "Using PFX password from provided PSCredential" -Level INFO
            }
            if ($env:IFQC_DEV_PFX_PASSWORD) {
                $devPwd = $env:IFQC_DEV_PFX_PASSWORD
                $secure = New-Object System.Security.SecureString
                foreach ($ch in $devPwd.ToCharArray()) { $secure.AppendChar($ch) }
                $secure.MakeReadOnly()
                $CertPassword = $secure
                Write-SignedLog -Message "Using PFX password from IFQC_DEV_PFX_PASSWORD environment variable" -Level INFO
            } else {
                $CertPassword = Read-Host "Enter PFX password" -AsSecureString
            }
        }
        
        try {
            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2(
                $CertPath,
                $CertPassword,
                [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
            )
            return $cert
        } catch {
            Write-SignedLog -Message "Failed to load PFX: $($_.Exception.Message)" -Level ERROR
            return $null
        }
    }
    
    # Try local machine store
    Write-SignedLog -Message "Searching for Code Signing certificate in Local Machine store..." -Level INFO
    
    $cert = Get-ChildItem -Path Cert:\LocalMachine\My |
        Where-Object {
            $_.NotAfter -gt (Get-Date) -and
            $_.EnhancedKeyUsageList.ObjectIdentifier -contains "1.3.6.1.5.5.7.3.3"
        } | Sort-Object -Property NotAfter -Descending | Select-Object -First 1
    
    if ($cert) {
        Write-SignedLog -Message "Found certificate: $($cert.Subject)" -Level INFO
        return $cert
    }
    
    # Try current user store
    Write-SignedLog -Message "Searching for Code Signing certificate in Current User store..." -Level INFO
    
    $cert = Get-ChildItem -Path Cert:\CurrentUser\My |
        Where-Object {
            $_.NotAfter -gt (Get-Date) -and
            $_.EnhancedKeyUsageList.ObjectIdentifier -contains "1.3.6.1.5.5.7.3.3"
        } | Sort-Object -Property NotAfter -Descending | Select-Object -First 1
    
    if ($cert) {
        Write-SignedLog -Message "Found certificate: $($cert.Subject)" -Level INFO
        return $cert
    }
    
    Write-SignedLog -Message "No Code Signing certificate found." -Level ERROR
    Write-SignedLog -Message "Install a code signing certificate or provide -CertPath to PFX file." -Level WARN
    return $null
}

function Set-AuthenticodeSignature {
    <#
    .SYNOPSIS
        Signs a single file.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$true)]
        [System.Security.Cryptography.X509Certificates.X509Certificate2]$Certificate
    )
    
    if ($DryRun) {
        Write-SignedLog -Message "[DRY RUN] Would sign: $FilePath" -Level INFO
        return $true
    }
    
    try {
        # Check if already signed
        $existingSig = Get-AuthenticodeSignature -FilePath $FilePath -ErrorAction SilentlyContinue
        if ($existingSig -and $existingSig.Status -eq "Valid") {
            Write-SignedLog -Message "Already signed: $FilePath" -Level INFO
            $script:skipCount++
            return $true
        }
        
        # Sign the file
        $sig = Set-AuthenticodeSignature -FilePath $FilePath -Certificate $Certificate -TimestampServer "http://timestamp.digicert.com" -ErrorAction Stop
        
        if ($sig.Status -eq "Valid") {
            Write-SignedLog -Message "Signed: $FilePath" -Level INFO
            $script:signCount++
            return $true
        } else {
            Write-SignedLog -Message "Signature status: $($sig.Status) for $FilePath" -Level WARN
            return $false
        }
    } catch {
        Write-SignedLog -Message "Failed to sign $FilePath : $($_.Exception.Message)" -Level ERROR
        $script:failCount++
        return $false
    }
}

function Get-ScriptFiles {
    <#
    .SYNOPSIS
        Gets all signable files from the module path.
    #>
    param([string]$Path)
    
    $files = @()
    
    # Get ps1, psm1, psd1 files
    $files += Get-ChildItem -Path $Path -Recurse -Filter "*.ps1" -ErrorAction SilentlyContinue
    $files += Get-ChildItem -Path $Path -Recurse -Filter "*.psm1" -ErrorAction SilentlyContinue
    $files += Get-ChildItem -Path $Path -Recurse -Filter "*.psd1" -ErrorAction SilentlyContinue
    
    return $files
}

# Main execution
Write-SignedLog -Message "IdentityFirst QuickChecks - Script Signing" -Level INFO

if ($DryRun) {
    Write-SignedLog -Message "MODE: DRY RUN (no changes will be made)" -Level WARN
}

Write-SignedLog -Message "Module Path: $ModulePath" -Level INFO


# Get certificate
$certificate = Get-Certificate
# Certificate validation
if (-not $certificate) {
    Write-SignedLog -Message "Cannot proceed without a valid certificate." -Level ERROR
    exit 1
}

Write-SignedLog -Message "Certificate: $($certificate.Subject)" -Level INFO
Write-SignedLog -Message "Expires: $($certificate.NotAfter.ToString('yyyy-MM-dd'))" -Level INFO

# Get all files to sign
$files = Get-ScriptFiles -Path $ModulePath
Write-SignedLog -Message "Found $($files.Count) files to process" -Level INFO

# Process files
foreach ($file in $files) {
    $null = Set-AuthenticodeSignature -FilePath $file.FullName -Certificate $certificate
}

# Summary
Write-SignedLog -Message "Signing Complete" -Level INFO
Write-SignedLog -Message "Signed: $script:signCount; Skipped: $script:skipCount; Failed: $script:failCount" -Level INFO

if ($DryRun) {
    Write-SignedLog -Message "Run without -DryRun to actually sign the files." -Level WARN
}

if ($script:failCount -gt 0) {
    Write-SignedLog -Message "Some files failed to sign. Check errors above." -Level ERROR
    exit 1
}

Write-SignedLog -Message "All done!" -Level INFO
Write-Output ([PSCustomObject]@{ Signed = $script:signCount; Skipped = $script:skipCount; Failed = $script:failCount })

# SIG # Begin signature block
# MIIJyAYJKoZIhvcNAQcCoIIJuTCCCbUCAQExDzANBglghkgBZQMEAgEFADB5Bgor
# BgEEAYI3AgEEoGswaTA0BgorBgEEAYI3AgEeMCYCAwEAAAQQH8w7YFlLCE63JNLG
# KX7zUQIBAAIBAAIBAAIBAAIBADAxMA0GCWCGSAFlAwQCAQUABCBV05aYg6xnJ0Rr
# W3DrOMYU4/oadV7YFEsgxtA8wRFgnaCCBdYwggXSMIIDuqADAgECAhAxVnqog0nQ
# oULr1YncnW59MA0GCSqGSIb3DQEBCwUAMIGAMQswCQYDVQQGEwJHQjEXMBUGA1UE
# CAwOTm9ydGh1bWJlcmxhbmQxFzAVBgNVBAcMDk5vcnRodW1iZXJsYW5kMRowGAYD
# VQQKDBFJZGVudGl0eUZpcnN0IEx0ZDEjMCEGA1UEAwwaSWRlbnRpdHlGaXJzdCBD
# b2RlIFNpZ25pbmcwHhcNMjYwMTI5MjExMDU3WhcNMzEwMTI5MjEyMDU2WjCBgDEL
# MAkGA1UEBhMCR0IxFzAVBgNVBAgMDk5vcnRodW1iZXJsYW5kMRcwFQYDVQQHDA5O
# b3J0aHVtYmVybGFuZDEaMBgGA1UECgwRSWRlbnRpdHlGaXJzdCBMdGQxIzAhBgNV
# BAMMGklkZW50aXR5Rmlyc3QgQ29kZSBTaWduaW5nMIICIjANBgkqhkiG9w0BAQEF
# AAOCAg8AMIICCgKCAgEAtrU2HprgcHe9mxlmt5X72OsSk7cXDyUhoOAcLE9f4lS2
# rOx7VbZSMSi0r4lt8a/S5m/JIWCdYO+GrWZCgS2S73H3KNDszR5HDPbMhv+leoWA
# qLT7C0awpjcTnvWIDxnHyHHane/TNl3ehY9Jek5qrbiNgJDatV6SEYVFlK8Nk9kE
# 3TiveVvRKokNT2xY4/h1rohFCHnF+g7dCn06xAZwoGnFVlmPop3jItAlZdUQz3zR
# /xSNW01sQXgW6/TYd2VzXXuQihMQ3ikjoNGX1L8SlcV4ih2J+r2kSHjhkZ8c+wJE
# v2iiUHqpwmch31UwQOb4qklGKg1A+SAUGdf0cTTc6ApSFsqrol1euObreoy0zdAA
# k47NELuGhKA4N0Dk9Ar616JGFt/03s1waukNisnH/sk9PmPGUo9QtKH1IQpBtwWw
# uKel0w3MmgTwi2vBwfyh2/oTDkTfic7AT3+wh6O/9mFxxu2Fsq6VSlYRpSTSpgxF
# c/YsVlQZaueZs6WB6/HzftGzv1Mmz7is8DNnnhkADTEMj+NDo4wq+lUCE7XNDnnH
# KBN8MkDh4IljXVSkP/xwt4wLLd9g7oAOW91SDA2wJniyjSUy9c+auW3lbA8ybSfL
# TrQgZiSoepcCjW2otZIXrmDnJ7BtqmmiRff4CCacdJXxqNWdFnv6y7Yy6DQmECEC
# AwEAAaNGMEQwDgYDVR0PAQH/BAQDAgeAMBMGA1UdJQQMMAoGCCsGAQUFBwMDMB0G
# A1UdDgQWBBQBfqZy0Xp6lbG6lqI+cAlT7ardlTANBgkqhkiG9w0BAQsFAAOCAgEA
# IwBi/lJTGag5ac5qkMcnyholdDD6H0OaBSFtux1vPIDqNd35IOGYBsquL0BZKh8O
# AHiuaKbo2Ykevpn5nzbXDBVHIW+gN1yu5fWCXSezCPN/NgVgdH6CQ6vIuKNq4BVm
# E8AEhm7dy4pm4WPLqEzWT2fwJhnJ8JYBnPbuUVE8F8acyqG8l3QMcGICG26NWgGs
# A28YvlkzZsny+HAzLvmJn/IhlfWte1kGu0h0G7/KQG6hei5afsn0HxWHKqxI9JsG
# EF3SsMVQW3YJtDzAiRkNtII5k0PyywjrgzIGViVNOrKMT9dKlsTev6Ca/xQX13xM
# 0prtnvxiTXGtT031EBGXAUhOzvx2Hp1WFnZTEIJyX1J2qI+DQsPb9Y1jWcdGBwv3
# /m1nAHE7FpPGsSv+UIP3QQFD/j6nLl5zUoWxqAZMcV4K4t4WkPQjPAXzomoRaqc6
# toXHlXhKHKZ0kfAIcPCFlMwY/Rho82GiATIxHXjB/911VRcpv+xBoPCZkXDnsr9k
# /aRuPNt9DDSrnocJIoTtqIdel/GJmD0D75Lg4voUX9J/1iBuUzta2hoBA8fSVPS5
# 6plrur3Sn5QQG2kJt9I4z5LS3UZSfT+29+xJz7WSyp8+LwU7jaNUuWr3lpUnY2nS
# pohDlw2BFFNGT6/DZ0loRJrUMt58UmfdUX8FPB7uNuIxggNIMIIDRAIBATCBlTCB
# gDELMAkGA1UEBhMCR0IxFzAVBgNVBAgMDk5vcnRodW1iZXJsYW5kMRcwFQYDVQQH
# DA5Ob3J0aHVtYmVybGFuZDEaMBgGA1UECgwRSWRlbnRpdHlGaXJzdCBMdGQxIzAh
# BgNVBAMMGklkZW50aXR5Rmlyc3QgQ29kZSBTaWduaW5nAhAxVnqog0nQoULr1Ync
# nW59MA0GCWCGSAFlAwQCAQUAoIGEMBgGCisGAQQBgjcCAQwxCjAIoAKAAKECgAAw
# GQYJKoZIhvcNAQkDMQwGCisGAQQBgjcCAQQwHAYKKwYBBAGCNwIBCzEOMAwGCisG
# AQQBgjcCARUwLwYJKoZIhvcNAQkEMSIEIFl7I6QTUR989LckvWgVj809xRyhCMeb
# YSsmiuVCwJZqMA0GCSqGSIb3DQEBAQUABIICACy9fl5she8jCHXFwiLl9/6WnGpX
# lmREjTgH1NeXy+cUL9ihVkBChRQf15Yr5/CdRtK1JAFe3DAjk/v0qS8nAWOF7K8s
# vJHi74lXIBmi/JtE02EV1exX+EUFmItdyi/sGTr49Xi8coSI2sUMYjXf4kukrOcW
# eABWX/8S9DuXmlqrsQv+99Y55P2aqsvso+aGKM4306NxDP/YfL6Y9gsucP1iW1Pj
# 5o6g71ApCB80N9UFYa9Qpc+cA01OadMxQletGk8l2Uz4QqGL373+SQPlwZ2UJ7Db
# ZPwxmT0ZbLFn3lfoW33dOcVhda+11Bi16mkibeCVgCm9pxl9+alaOU7vq4fENasG
# Pv0rtNh1Z1wbvjqOZjGr9RVqRQiONCIcSIZyPFkaM/AyTYInVQFHJ61UGPwU4LHE
# 06dTatGUA9gK0rwDMxBaIywurEGivgCKgJfaXXfCabugSvUDKG+Aub/x9VIPSzRg
# IGWXBXt9u92UdE9JXA7WbR6ezPsdJd4S11O3HEBuhkWG/hCY1t23xAtBeq4T9jxw
# BrTpqMFQ18/XFpCiz0FXYm2oZidLw4xlbgE5zm0dEU5gTAVNT8wwWfzb/Bmdy0SU
# 6btX1vkbneEnAvsI5vZo7Zao9CkjflPoXKD09on8nRbKulCjmiVy7+nAXu8E2Kzl
# SFWIj3UeU4CRqMYz
# SIG # End signature block
